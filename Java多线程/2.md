# Java多线程系列2: 锁
本文是作者的读博客笔记和心得整理，也引用了一些比较好的博客文章,部分内容来源于网络，如有侵权，请联系作者。

## 什么是锁
锁即为保护一个共享代码块(临界区)只能被一个线程进行访问.使用synchronized,在public后面,返回值前面

被锁保护的共享变量在释放锁之前是对其他线程不可见的,在B拿到锁之后立刻可见.

主要的操作是当线程A释放锁的时候,JMM会立刻把A的共享变量刷新到主内存去.这样B拿到锁的时候,B的本地内存被置为无效,从而使得B必须去主内存中获取.

## Synchronized关键字
首先,Java中的所有对象都可以作为锁.
普通同步方法，锁的是当前实例对象
静态同步方法锁的是当前类对象
同步方法块锁的是括号里面对象

### Java对象头
对象头主要包括两部分的数据：Mark Word（标记字段），KClass Pointer（类型指针）
类型指针是对象指向它的类元数据的指针，用来确定这个对象是哪个类的
Mark Word用于存储对象自身运行时的数据，是实现轻量级锁和偏向锁的关键。

### Monitor
每个对象都带有这么一个内部锁，是线程私有的一个数据结构，每一个线程都有一个monitor record列表，每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

## 锁优化
锁主要存在4种状态，无锁，偏向锁，轻量级锁，重量级锁，会随着竞争的激烈而逐渐升级，但是锁是不可以降级的，这样是为了提高获得和释放锁的效率

## 自旋锁
线程的阻塞和唤醒需要CPU从用户态转换为核心态，频繁的阻塞和唤醒给系统的并发造成很大的压力。
自旋锁就是为了解决锁状态只需要持续很短时间的case

自旋的意思就是让来获取该锁的线程不要立刻挂起，而是等待一段时间看看是否锁很快会被释放。

等待的时间就是执行一段无意义的循环，如果等待了一段时间锁还是没释放，那就挂起。

### 适应自旋锁
如果上次自旋成功，下次就多自旋一些。这样虚拟机会越来越聪明。

