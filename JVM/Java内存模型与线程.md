## Java 内存模型和线程
原因：计算机的运算速度和它的存储与通信子系统速度差距太大
衡量一个服务性能的高低好坏，每秒事物处理数（Transactions Per Second，TPS）是最重要的指标，代表着一秒内服务端能响应的请求总数

## 3.1 硬件效率与一致性
由于计算机的存储设备与处理器的运算速度有几个数量级的差距，现代计算机都加有高速缓存Cache：把运算需要用的数据复制到缓存中，运算结束后再从缓存同步回内存中

引入了一个新的问题：缓存一致性（Cache Coherence），每个处理器都有自己的高速缓存，但是他们又共享同一主内存（main memory）

额外的优化方式：处理器的乱序执行（Out-Of-Order Execution)

## 3.2 Java 内存模型
#### 3.2.1 主内存和工作内存
内存中的变量包括实例字段，静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，后者是线程私有的，不会被共享。
内存模型规定所有变量存在主内存（Main Memory）中，每个线程还有自己的工作内存（Working Memory），保存了被该线程使用到的主内存到副本拷贝。

### 3.2.2 内存间交互操作
定义了以下8种操作：全部都是原子的，不可拆分
lock（锁定）：作用于主内存的变量，把某个变量识别为一条线程独占的状态
unlock（解锁）：作用于主内存
read：从主内存传输到工作内存
load：作用于工作内存，放入变量副本中
use：把工作内存中得到的变量值传递给执行引擎
assign：把执行引擎中的变量的值给工作内存中的变量
store：把工作内存的值传递给主内存
write：把store传递来的值写入到主内存

注意以上操作有先后顺序，但是不一定是连续的，必须满足以下条件：
对一个变量实施use和store之前必须要执行assign和load操作
lock过程可以执行多次
对一个变量执行lock会把工作内存中该变量的值清空。
unlock之前必须先同步回主内存中

### 3.2.3 对于volatile型变量的特殊规则
第一，此变量对所有线程可见。当一个线程修改了该值，所有线程都能立刻得知。普通变量不能做到这一点，需要通过主内存来完成。
但是这并不意味着它是线程安全的，所以有两条必须要满足的运算场景：
1，运算结果并不依赖变量的当前值，或者当前能确保只有单一的线程修改变量的值
2，变量不需要与其他状态变量共同参与不变约束。

第二，volatile变量可以禁止指令重排序

### 3.2.4 对于long和double的特殊规则
允许不保证64位数据结构8个操作的原子性


### 3.2.5 原子性，可见性，有序性
原子性（Atomicity）：基本数据类型的读写访问是原子的，synchronized块也是原子性的。
可见性（Visibility）：当一个线程修改了共享变量的值，其他的线程能够立刻知道这个修改。用volatile和synchronized以及final 关键字可以实现。
有序性（Ordering）：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。


### 3.2.6 先行并发原则Happens-before
控制流顺序，一个程序中先发生的部分比后发生的部分早
管程锁定规则，unlock》后一次的lock
volatile变量规则，对一个变量的写操作先行发生于后面的读
线程启动规则：start方法先行发生于此线程的每一个动作。
线程终止规则：线程中的所有操作都优先于终止动作。

## 3.3 Java与线程

### 3.3.1 线程的实现
1.使用内核线程实现
内核线程Kernel-Level Thread，KLT就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器Scheduler进行调度，并且负责将线程的任务映射到各个处理器上。
弊端：基于内核线程实现，所以各种线程操作都需要系统调用，而系统调用的代价相对较高，需要在用户态和内核态之间相互切换
而且需要一个内核线程的支持，消耗内核资源

2.使用用户线程实现
用户线程的意思是内核不能感知到用户线程的存在，很少有人使用

3.使用用户线程加轻量级进程混合实现

4.Java 线程的实现
和操作系统保持一致

### 3.3.2 Java线程调度
协同式线程调度：线程的执行时间由线程本身来控制，要主动通知系统切换到另外一个线程上。
缺点：线程时间不可控。

抢占式线程调度：系统分配线程执行时间，可以设定线程优先级

### 3.3.3 状态转换
拥有5种状态：新建new-运行runable-无限期等待waiting-限期等待Timed Waiting-阻塞Blocked-结束Terminated





