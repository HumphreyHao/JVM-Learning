# 深入理解java虚拟机--2
	垃圾收集器和内存分配策略
## 2.1概述
主要关心Java 堆中的部分内存

## 2.2 对象已死吗
死亡对象=不可能再被以任何方式引用的对象

### 2.2.1 引用计数算法 Reference Counting
给对象添加一个引用计数器，每当有一个地方引用他，计数器加一；引用失效的时候计数器减1
问题：很难解决对象之间循环引用的问题

### 2.2.2可达性分析算法Reachability Analysis
从GC Root作为起点向下搜索，搜索走过的路径称为引用链（Reference Chain）。某个对象是不可达的时候就会被回收

GC Root 的对象包括下面几种：
虚拟机栈中引用的对象
方法区中类静态属性引用对象
方法区中常量引用的对象
本地方法栈中JNI（Native 方法）引用的对象

###  2.2.3 再谈引用
强引用：在代码中普遍存在的引用
软引用：有用但是非必须，在系统将要发生内存溢出异常的时候会把这些对象回收
弱引用：只能存活到下次垃圾回收发生之前，在垃圾回收时必定会被回收
虚引用：在这个对象被回收的时候可以收到一个通知

### 2.2.4 再谈死亡
一个对象死亡要经历两次标记过程：
在进行可达性分析之后发现没有和root相连的部分，标记一次，判断是否需要进行finalize（）方法。如果被判断为需要执行，那么这个对象进入F-Queue队列。如果对象在finalize过程中与引用链上的任何对象发生了关联，第二次标记时会把它移出队列。
注意每个对象的finalize方法只会被系统自动调用一次，第二次回收的时候不会再给挣脱机会，直接回收

### 2.2.5回收方法区
包含废弃常量和无用的类
无用的类：
该类的所有实例都已经被回收
加载该类的ClassLoader已经被回收
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
## 2.3 垃圾回收算法
### 2.3.1 标记-清除算法Mark-Sweep
最基础，本质就是先标记之后再回收
有两个不足：
1.效率，标记和清除这两个过程效率都不是特别高
2.空间，标记清除之后会产生大量的不连续内存碎片

### 2.3.2 复制-收集算法Copy-Collect
解决效率问题，将可用内存按照容量划分为大小相等的两块，每次只使用一块，这一块用完了就把还存活的对象复制到另外一个块上，再把已经使用过的全部释放，优点是按顺序分配内存，缺点是内存缩小为原来的一半

现代算法：将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用一个E和一个S。回收的时候将E和S中还存活的对象一次性复制到另外一块上。默认是8:1:1，每次可用空间为新生代的90%。当S空间不够用时，需要使用老年代进行分配担保（Handle Promotion）

### 2.3.3 标记-整理算法Mark-Compact
和标记清除的原理一致，但是后续过程是所有存活对象都向一端移动，然后直接清理掉边界以外的内存

### 2.3.4 分代收集算法Generational Collection
把堆划分为新生代和老年代，新生代选择复制算法，大批死去；老年代使用标记整理，因为存活率很高

## 2.4 HotSpot的算法实现
### 2.4.1 枚举根结点
GC进行时必须停止所有的线程
生成OopMap存储对应的对象引用

### 2.4.2 安全点
如果为每一个指令都生成对应的OopMap，需要大量的额外空间
解决方案是在一些SafePoint安全点生成，然后暂停进程开始GC
一般选择在“长时间执行处”，类似于循环跳转，方法调用等

抢先式中断（Preemptive Suspension）
在Gc发生时把所有线程全部中断，然后恢复没有到安全点的线程跑到安全点

主动式中断（Volunary Suspension）
当GC需要中断线程的时候，设置一个标志，个线程执行时主动去轮询这个标志，发现标志为真时就自己挂起

### 2.4.3 安全区域Safe Region
用于解决当线程不运行的时候的挂起问题，特指在一端代码片段中引用关系不会发生变化，这个区域中的任意地方开始GC都是安全的

## 2.5 垃圾收集器
### 2.5.1 Serial收集器
单线程，在工作时必须停止所有的其他工作线程，直到他收集结束。
一般工作在运行在client模式下的新生代虚拟机

### 2.5.2 ParNew收集器
Serial收集器的多线程版，运行在Server模式下，目前只有这两种收集器可以和CMS收集器一起工作。

### 2.5.3 Parallel Scavenge
是一个新生代的收集器，使用复制算法，并行
目标是达到一个可控制的吞吐量（Throughput）

拥有监控系统，使用自适应调节策略GC Ergonomics
相关参数：
MaxGCPauseMillis：收集器将尽可能的保证内存回收花费的时间不超过这个设定值
GCTimerRatio：垃圾收集时间占总时间的比率
UseAdaptiveSizePolicy：开关参数，打开之后就不需要手工指定新生代的大小，Eden和S区的比例了

### 2.5.4 Serial Old收集器
Serial收集器的老年代版本，使用标记-整理算法

### 2.5.5 Parallel Old收集器
Parallel Scavenge老年代版本，标记-整理算法

### 2.5.6 CMS收集器Concurrent Mark Sweep
使用标记-清除算法实现，分为4个步骤：
初始标记：CMS initial mark，记录一下root能直接关联到的对象
并发标记：CMS concurrent mark，进行分析标记
重新标记：CMS remark，修正并发标记期间因为用户运行程序产生变动的部分记录
并发清除：CMS concurrent sweep

有以下的缺点：
1.对CPU资源非常的敏感
2.无法处理浮动垃圾
3.基于标记清除算法，会有大量的碎片产生

### 2.5.7 G1收集器Garbage-First
优点：
1.并行并发
2.分代收集
3.空间整合，运行期间不会产生内存空间碎片
4.可以预测的停顿
将整个java堆划分为多个大小相等的独立区域，虽然还有新生代和老年代的概念，但是不再是物理隔离的了，都是一些region的集合
G1还可以跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，优先回收价值最大的那个

为了避免全堆扫描，引入Remembered Set，每个Region对应一个，在产生reference的时候把相关有用的信息记录到被引用对象的set当中去

### 2.5.8 理解GC日志
参看书

## 2.6 内存分配与回收策略
### 2.6.1 对象优先在Eden 分配
大多数情况下，对象优先在E区分配。如果E区空间不足，执行一次minor GC（新生代专有GC）

### 2.6.2 大对象直接进入老年代

### 2.6.3 长期存活的对象进入老年代
给每一个对象定义了一个计数器，当计数器当值大于阈值时就会被放入老年区

### 2.6.4 动态对象年龄判定
如果S空间中相同年龄的所有对象大小的总和大于S空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代

### 2.6.5 空间分配担保
minor GC之前要先进行判断是否安全，如果不安全就需要担保，或者进行一次full GC





















