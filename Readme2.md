# 深入理解java虚拟机--2
	垃圾收集器和内存分配策略
## 2.1概述
主要关心Java 堆中的部分内存

## 2.2 对象已死吗
死亡对象=不可能再被以任何方式引用的对象

### 2.2.1 引用计数算法 Reference Counting
给对象添加一个引用计数器，每当有一个地方引用他，计数器加一；引用失效的时候计数器减1
问题：很难解决对象之间循环引用的问题

### 2.2.2可达性分析算法Reachability Analysis
从GC Root作为起点向下搜索，搜索走过的路径称为引用链（Reference Chain）。某个对象是不可达的时候就会被回收

GC Root 的对象包括下面几种：
虚拟机栈中引用的对象
方法区中类静态属性引用对象
方法区中常量引用的对象
本地方法栈中JNI（Native 方法）引用的对象

###  2.2.3 再谈引用
强引用：在代码中普遍存在的引用
软引用：有用但是非必须，在系统将要发生内存溢出异常的时候会把这些对象回收
弱引用：只能存活到下次垃圾回收发生之前，在垃圾回收时必定会被回收
虚引用：在这个对象被回收的时候可以收到一个通知

### 2.2.4 再谈死亡
一个对象死亡要经历两次标记过程：
在进行可达性分析之后发现没有和root相连的部分，标记一次，判断是否需要进行finalize（）方法。如果被判断为需要执行，那么这个对象进入F-Queue队列。如果对象在finalize过程中与引用链上的任何对象发生了关联，第二次标记时会把它移出队列。
注意每个对象的finalize方法只会被系统自动调用一次，第二次回收的时候不会再给挣脱机会，直接回收

### 2.2.5回收方法区
包含废弃常量和无用的类
无用的类：
该类的所有实例都已经被回收
加载该类的ClassLoader已经被回收
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
## 2.3 垃圾回收算法
### 2.3.1 标记-清除算法Mark-Sweep
最基础，本质就是先标记之后再回收
有两个不足：
1.效率，标记和清除这两个过程效率都不是特别高
2.空间，标记清除之后会产生大量的不连续内存碎片

### 2.3.2 复制-收集算法Copy-Collect
解决效率问题，将可用内存按照容量划分为大小相等的两块，每次只使用一块，这一块用完了就把还存活的对象复制到另外一个块上，再把已经使用过的全部释放，优点是按顺序分配内存，缺点是内存缩小为原来的一半

现代算法：将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用一个E和一个S。回收的时候将E和S中还存活的对象一次性复制到另外一块上。默认是8:1:1，每次可用空间为新生代的90%。当S空间不够用时，需要使用老年代进行分配担保（Handle Promotion）

### 2.3.3 标记-整理算法Mark-Compact
和标记清除的原理一致，但是后续过程是所有存活对象都向一端移动，然后直接清理掉边界以外的内存

### 2.3.4 分代收集算法Generational Collection
把堆划分为新生代和老年代，新生代选择复制算法，大批死去；老年代使用标记整理，因为存活率很高

## 2.4 HotSpot的算法实现
### 2.4.1 枚举根结点
GC进行时必须停止所有的线程
生成OopMap存储对应的对象引用

### 2.4.2 安全点
如果为每一个指令都生成对应的OopMap，需要大量的额外空间
解决方案是在一些SafePoint安全点生成，然后暂停进程开始GC
一般选择在“长时间执行处”，类似于循环跳转，方法调用等

抢先式中断（Preemptive Suspension）
在Gc发生时把所有线程全部中断，然后恢复没有到安全点的线程跑到安全点
















