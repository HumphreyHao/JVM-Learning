# 深入理解java虚拟机--2
	垃圾收集器和内存分配策略
## 2.1概述
主要关心Java 堆中的部分内存

## 2.2 对象已死吗
死亡对象=不可能再被以任何方式引用的对象

### 2.2.1 引用计数算法 Reference Counting
给对象添加一个引用计数器，每当有一个地方引用他，计数器加一；引用失效的时候计数器减1
问题：很难解决对象之间循环引用的问题

### 2.2.2可达性分析算法Reachability Analysis
从GC Root作为起点向下搜索，搜索走过的路径称为引用链（Reference Chain）。某个对象是不可达的时候就会被回收

GC Root 的对象包括下面几种：
虚拟机栈中引用的对象
方法区中类静态属性引用对象
方法区中常量引用的对象
本地方法栈中JNI（Native 方法）引用的对象

###  2.2.3 再谈引用
强引用：在代码中普遍存在的引用
软引用：有用但是非必须，在系统将要发生内存溢出异常的时候会把这些对象回收
弱引用：只能存活到下次垃圾回收发生之前，在垃圾回收时必定会被回收
虚引用：在这个对象被回收的时候可以收到一个通知

### 2.2.4 再谈死亡
一个对象死亡要经历两次标记过程：
在进行可达性分析之后发现没有和root相连的部分，标记一次，判断是否需要进行finalize（）方法。如果被判断为需要执行，那么这个对象进入F-Queue队列。如果对象在finalize过程中与引用链上的任何对象发生了关联，第二次标记时会把它移出队列。
注意每个对象的finalize方法只会被系统自动调用一次，第二次回收的时候不会再给挣脱机会，直接回收

### 2.2.5回收方法区
包含废弃常量和无用的类
无用的类：
该类的所有实例都已经被回收
加载该类的ClassLoader已经被回收
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
## 2.3 垃圾回收算法
### 2.3.1 标记-清除算法Mark-Sweep









